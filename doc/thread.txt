===============================================================================

    C++ backports Library
                 <thread.hpp>

===============================================================================

<APIリファレンス>
https://sites.google.com/site/cpprefjp/reference/thread

<使用方法>
いずれの使用方法でも構築と同時にスレッドが作動し始める。

・関数をスレッドワーカにする(引数無し)
+----------------------------------
| void worker(void) {
|     // ...
| }
|
| std11::thread t(worker);
+----------------------------------
  ※ワーカに指定する関数名には&を付けても付けなくても良い

・関数をスレッドワーカにする(引数指定)
+----------------------------------
| void worker2(int arg) {
|     // ...
| }
|
| std11::thread t(worker2, 20);  // worker(20)が開始される
+----------------------------------

・関数オブジェクトをスレッドワーカにする(引数無し)
+----------------------------------
| class Worker {
| public:
|     operator ()(void) {
|         // ...
|     }
| };
|
| Worker worker_obj;
| std11::thread t(worker_obj);
+----------------------------------

・関数オブジェクトをスレッドワーカにする(引数指定)
+----------------------------------
| class Worker2 {
| public:
|     operator ()(int arg) {
|         // ...
|     }
| };
|
| Worker2 worker_obj;
| std11::thread t(worker_obj, 30);  // worker_obj.operator()(30)が開始される
+----------------------------------

・非staticなメンバ関数をスレッドワーカにする
  第2引数にオブジェクトインスタンス、参照、もしくはポインタを指定する。
+----------------------------------
| class Worker3 {
| public:
|     int member_func(void) {
|         // ...
|     }
|     int member_func_with_arg(int arg) {
|         // ...
|     }
| };
|
| Worker3 worker_obj;
| std11::thread t1(&Worker3::member_func,          &worker_obj);
| std11::thread t2(&Worker3::member_func_with_arg, &worker_obj, 30);
| std11::thread t3(&Worker3::member_func,          worker_obj);
+----------------------------------
※インスタンスを指定する方法には3種類あり、それぞれで動作が異なるので注意。
  * ポインタか参照を指定した場合
    -> 引数に指定したインスタンスがthreadオブジェクトで使用される。
  * インスタンスを渡した場合
    -> そのインスタンスが複製され、コピー後のインスタンスでメンバ関数が
       実行される。
       (上記t3のスレッド)
  尚、参照指定する場合はref関数でラップすること。
  (std11::refのドキュメントも参照)

またここに挙げたような関数の実体を渡す方法の他、bindやfunctionのインスタンスも
コンストラクタに渡すことが可能。
それらのインスタンスを渡す場合、bindプレースホルダで遅延バインドされた引数も
含め、全引数がthreadコンストラクト時点で確定される必要がある。

・スレッド固有のIDを取得する
  スレッドIDオブジェクトをハッシュ化する関数オブジェクトをインスタンス化し、
  その関数オブジェクトを使ってIDを取り出す。
  (hashの返り値はsize_tで返却される。)
  get_id()の結果はオブジェクトであり、数値ではない点に注意すること。
+----------------------------------
| std11::hash<std11::thread::id> tid_hasher;
|
| std11::thread t1(func);
| size_t t1_id = tid_hasher(t1.get_id());
|
| size_t this_thread_id = tid_hasher(std11::this_thread::get_id());
+----------------------------------

<注意事項>
glibcでthreadを使う場合、リンク時に -lpthread を指定する必要がある。
(指定しなかった場合はスレッド起動時に異常終了が発生する。)

threadオブジェクトのコンストラクタに渡すワーカ関数と第2引数以降の引数の
個数や型が一致しない場合、一見非常に難解なコンパイルエラーが出力される。
コンパイルに失敗する場合はまず第2引数以降に渡している値が正しいかどうかを
確認すると良い。

アクティブなthreadのインスタンスに対してdetach、joinのいずれも行わずに
ムーブ代入、デストラクタの何れかが実行された場合、std::terminate()により
プログラムが異常終了する。
(アクティブなthreadとはjoinableの結果がtrueとなるthreadの事を指す。
すなわち、引数なしのコンストラクタ以外で構築され、joinもdetachも行われて
いないインスタンスが該当する。)

threadを初期化するときにオーバーロードされた関数ポインタを渡す場合、
関数名を一意に決定できない為、コンパイルが失敗する。
この場合はbindないしfunctionを使って関数オブジェクトにラップすると良い。
【例】
+----------------------------------
| int func(void) {
|     return 42;
| }
|
| int func(int n) {
|     return func() * n;
| }
|
| std11::thread t1(func);    // func(void) と func(int) の
|                            // どちらなのかを決定できない
|
| std11::function<int(void)> f0 = func;
|                            // これもt1と同様の理由でNG
|
| std11::function<int(void)> f1 = std11::bind(func);
| std11::thread t2(f1);      // これならOK (func(void)を使用)
|
| std11::thread t3(std11::bind(func, 20)); // これもOK (func(int) を使用)
|
| std11::function<int(int)> f2
|     = std11::bind(overloaded, std11::placeholders::_1);
| std11::thread t4(f2, 33);  // これもOK
|                            // bindで関数の第1引数を未確定のまま束縛し、
|                            // threadインスタンス化時に引数を確定
+----------------------------------

コンストラクタに渡された引数は全てコピーされるため、そのままではスレッド内で
渡された引数の値を書き換えることができない。
渡された引数の値をスレッド内で書き換えたい場合はstd11::refでラップした物を
引数に渡すこと。
また上記に関連し、コンストラクタに渡す引数は全てコピーコンストラクト可能で
あることが要求される。
【例】
+----------------------------------
| void twice(int& i) {
|     i *= 2;
| }
|
| int main(void) {
|     int a = 100, b = 200;
|
|     std11::thread t1(twice, a);
|     std11::thread t2(twice, std11::ref(b));
|
|     t1.join();
|     t2.join();
|
|     printf("a=%d, b=%d\n", a, b);   // "a=100, b=400" を出力
| }
+----------------------------------

<課題>
現状の実装ではスレッドワーカから返却される値を取得することができない。
そのため処理結果を取得したい場合は個々のスレッドワーカ自身で終了前に他の
スレッドと共有している変数に値を格納するといった作り方をする必要がある。
(async-futureによる非同期処理結果取得を使用すればワーカごとの個別対応は
不要となる。)

<C++11と比較した時の制限事項>
C++11ではコンストラクタに任意の数の引数を記述してワーカを起動できるが
C++03では言語文法上任意個数のテンプレートがサポートされない為、
ワーカに渡せる引数上限は9個までとなっている。
(すなわちthreadのコンストラクタの引数上限は10個)

